<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-training-aug19</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="installation_win.html"><strong aria-hidden="true">1.</strong> Installation (Windows)</a></li><li class="chapter-item expanded "><a href="installation_mac.html"><strong aria-hidden="true">2.</strong> Installation (Mac)</a></li><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">3.</strong> Installation (Linux)</a></li><li class="chapter-item expanded "><a href="anatomy.html"><strong aria-hidden="true">4.</strong> Anatomy</a></li><li class="chapter-item expanded "><a href="data_types.html"><strong aria-hidden="true">5.</strong> Data types</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">6.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="external_dependencies.html"><strong aria-hidden="true">7.</strong> External dependencies</a></li><li class="chapter-item expanded "><a href="borrowing.html"><strong aria-hidden="true">8.</strong> Borrowing, cloning, and scopes</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">9.</strong> Testing</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">10.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="convolve.html"><strong aria-hidden="true">11.</strong> Convolve</a></li><li class="chapter-item expanded "><a href="sobel.html"><strong aria-hidden="true">12.</strong> Sobel</a></li><li class="chapter-item expanded "><a href="extra.html"><strong aria-hidden="true">13.</strong> Extra: Arguments libraries</a></li><li class="chapter-item expanded "><a href="org.html"><strong aria-hidden="true">14.</strong> Extra: Code Organization &amp; Modules</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">rust-training-aug19</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sobel-edge-detection"><a class="header" href="#sobel-edge-detection">Sobel Edge Detection</a></h1>
<p>Rust is a systems language pursuing the trifecta: safety, concurrency, and speed. This makes it well suited to machine learning and data science tasks. Rust experience will not be required, only existing programming experience.</p>
<p>We'll spend half the session on a with an introduction to Rust and the rest using functional programming style to develop a machine learning primitive called Convolve which can be used for many tasks including edge detection, sharpening, blur and more.</p>
<p>Our main goal will be the <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel operator</a>. In a Sobel operator pixels in an image are 'convolved' with the Sobel kernel to produce an output that highlights edges.</p>
<p><img src="./images/valve_sobel.png" alt="After Sobel" /></p>
<p><a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution">Convolution</a> is an incredibly common machine learning operation and maybe you'll walk away understanding a little more about whats going on in convolutional neural networks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-rust-with-rustup"><a class="header" href="#installing-rust-with-rustup">Installing Rust with Rustup</a></h1>
<ol>
<li>
<p>Visit <a href="https://rustup.rs">rustup.rs</a>, download, and then run rustup-init.exe</p>
<p><img src="./images/install/rustup.png" alt="Rustup website" /></p>
</li>
<li>
<p>Make sure you have the dependencies met. The Rust installation includes the Rust compiler, but Rust uses the system linker to create the final executables and link to system shared libraries (DLLs). So, we have to make sure a usable linker and system libraries are installed.</p>
<ol>
<li>If you already have one of the listed Visual Studio versions installed with C++ build tools, the dependencies should be met already
<ol>
<li>If later you get an error about &quot;Link.exe&quot;, follow step 2</li>
</ol>
</li>
<li>Otherwise, install these:
<ol>
<li><a href="https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk">Windows 10 SDK</a></li>
<li><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj647KSzY_kAhXCPn0KHV5nC4IQFjAAegQIAhAB&amp;url=https%3A%2F%2Fgo.microsoft.com%2Ffwlink%2F%3FLinkId%3D691126&amp;usg=AOvVaw0geDw_h-TSCfzTMvYE2ZOw">Microsoft Visual C++ build tools</a></li>
</ol>
</li>
</ol>
<p><img src="./images/install/rustup2.png" alt="Rustup deps" /></p>
</li>
<li>
<p>Press <code>1</code> and then <code>enter</code> to proceed with the installation</p>
<p><img src="./images/install/rustup3.png" alt="Proceed with install" /></p>
</li>
<li>
<p>Once the installation is complete, the below message should show. Press <code>enter</code> to close the window.</p>
<p><img src="./images/install/rustup4.png" alt="Installation finished" /></p>
</li>
<li>
<p>Test the rustup installation:</p>
<ol>
<li>Open a new command prompt window</li>
<li>Run the command <code>rustup</code>. The command should show help information.</li>
</ol>
<p><img src="./images/install/rustuphelp.png" alt="Rustup help" /></p>
<ol start="3">
<li>If the <code>rustup</code> command fails, add <code>%USERPROFILE%\.cargo\bin</code> to your <code>PATH</code> environment variable.</li>
</ol>
</li>
<li>
<p>Install the Rust Language Server (RLS):</p>
<ol>
<li>Open a command prompt window (you can reuse the same window)</li>
<li>Run the command <code>rustup component add rls</code>. The command should download and install the RLS.</li>
</ol>
<p><img src="./images/install/rustup5.png" alt="Installing Rust language server" /></p>
<ol start="3">
<li>Install the rustfmt component by running the command <code>rustup component add rustfmt</code></li>
</ol>
<p><img src="./images/install/rustupfmt.png" alt="Installing Rust language server" /></p>
</li>
</ol>
<h2 id="choosing-your-editor"><a class="header" href="#choosing-your-editor">Choosing your editor</a></h2>
<p>You only need one of the following editors, or another if you prefer a different one, but the goal is for you to have RLS and Code Formating (rustfmt) installed and enabled.</p>
<h3 id="configuring-gvim-8x-for-rust-with-the-rls"><a class="header" href="#configuring-gvim-8x-for-rust-with-the-rls">Configuring GVim 8.x for Rust with the RLS</a></h3>
<p>The steps below configure GVim 8.x on Windows to support Rust and use the Rust Language Server (RLS) for autocompletion.</p>
<ol>
<li>Make sure you have a working Git installation. (<a href="https://git-scm.com/download/win">Download Here for Windows</a>)</li>
<li>Visit <a href="https://rls.booyaa.wtf">https://rls.booyaa.wtf</a> and follow the steps for your preferred Vim package management strategy.</li>
<li>Modify your vimrc to include the below snippet. The guide linked in the previous step is still configured to use the Rust nightly build, since the RLS used to only be available in the nightly builds. RLS is now available in stable, and we installed stable Rust (the default). The below snippet should replace the one from the linked guide, and changes the 'cmd' to use stable instead of nightly.</li>
</ol>
<pre><code class="language-text">if executable('rls')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'rls',
        \ 'cmd': {server_info-&gt;['rustup', 'run', 'stable', 'rls']},
        \ 'whitelist': ['rust'],
        \ })
endif
</code></pre>
<ol start="4">
<li>
<p>Make sure <code>filetype plugin indent on</code> and <code>syntax enable</code> and lets add format on save as well like <code>let g:rustfmt_autosave = 1</code></p>
</li>
<li>
<p>Restart GVim or reload your vimrc</p>
</li>
<li>
<p>Open a Rust file and test our autocompletion (for example start typing <code>use std::</code>)</p>
<p><img src="./images/install/gvimrls.png" alt="GVim Rust autocompletion" /></p>
</li>
</ol>
<h3 id="configuring-vs-code-for-rust-with-the-rls"><a class="header" href="#configuring-vs-code-for-rust-with-the-rls">Configuring VS Code for Rust with the RLS</a></h3>
<p>The steps below configure VS Code on Windows to support Rust and use the Rust Language Server (RLS) for autocompletion and incremental compilation to display warnings and errors.</p>
<ol>
<li>
<p>Install the Rust (rls) extension by user 'rust-lang' in VS Code. There are several other plugins, but this one is the most maintained.</p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>If you see an error message that the RLS could not be started or that the extension could not find rustup, then you will have to configure VS Code's path for rustup:</p>
<ol>
<li>
<p>Open VS Code preferences and navigate to the Rust extension preferences</p>
</li>
<li>
<p>Modify the rustup path to use an absolute path to your installation: <code>C:\Users\&lt;username&gt;\.cargo\bin\rustup</code></p>
<p><img src="./images/install/vscode_rust.png" alt="VS Code rustup path" /></p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>You may see a prompt in the lower-right to install the RLS. If so, click yes.</p>
</li>
</ol>
</li>
<li>
<p>Open a Rust file and test out the RLS:</p>
<ol>
<li>Try autocompletion (for example start typing <code>use std::</code>) at the top of a file</li>
<li>Try the incremental compilation (for example <code>println!(&quot;Hello, world!&quot;) blah blah 42 42</code> should show an inline error)</li>
</ol>
<p><img src="./images/install/vscode_rust2.png" alt="VS Code Rust autocompletion and incremental compilation" /></p>
</li>
<li>
<p>Enable format on save in VScode settings. Code-&gt;Preferences-&gt;Settings-&gt;Text Editor-&gt;Formatting-&gt;Format On Save</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-rust-with-rustup-1"><a class="header" href="#installing-rust-with-rustup-1">Installing Rust with Rustup</a></h1>
<ul>
<li>Visit <a href="https://rustup.rs">rustup.rs</a>, to install the rust toolchain.</li>
</ul>
<h2 id="choosing-your-editor-1"><a class="header" href="#choosing-your-editor-1">Choosing your editor</a></h2>
<p>Whatever editor you choose, the goal is for you to have RLS and Code Formating (rustfmt) installed and enabled. VSCode is a mature and populare solution for Rust.</p>
<h3 id="configuring-vs-code-for-rust-with-the-rls-1"><a class="header" href="#configuring-vs-code-for-rust-with-the-rls-1">Configuring VS Code for Rust with the RLS</a></h3>
<p>The steps below configure VS Code on Mac to support Rust and use the Rust Language Server (RLS) for autocompletion and incremental compilation to display warnings and errors.</p>
<ol>
<li>
<p>Install the Rust (rls) extension by user 'rust-lang' in VS Code. There are several other plugins, but this one is the most maintained.</p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>If you see an error message that the RLS could not be started or that the extension could not find rustup, then you will have to configure VS Code's path for rustup:</p>
<ol>
<li>
<p>Open VS Code preferences and navigate to the Rust extension preferences</p>
</li>
<li>
<p>Modify the rustup path to use an absolute path to your installation: <code>C:\Users\&lt;username&gt;\.cargo\bin\rustup</code></p>
<p><img src="./images/install/vscode_rust.png" alt="VS Code rustup path" /></p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>You may see a prompt in the lower-right to install the RLS. If so, click yes.</p>
</li>
</ol>
</li>
<li>
<p>Open a Rust file and test out the RLS:</p>
<ol>
<li>Try autocompletion (for example start typing <code>use std::</code>) at the top of a file</li>
<li>Try the incremental compilation (for example <code>println!(&quot;Hello, world!&quot;) blah blah 42 42</code> should show an inline error)</li>
</ol>
<p><img src="./images/install/vscode_rust2.png" alt="VS Code Rust autocompletion and incremental compilation" /></p>
</li>
<li>
<p>Enable format on save in VScode settings. Code-&gt;Preferences-&gt;Settings-&gt;Text Editor-&gt;Formatting-&gt;Format On Save</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-rust-with-rustup-2"><a class="header" href="#installing-rust-with-rustup-2">Installing Rust with Rustup</a></h1>
<ul>
<li>Visit <a href="https://rustup.rs">rustup.rs</a>, to install the rust toolchain.</li>
</ul>
<h2 id="choosing-your-editor-2"><a class="header" href="#choosing-your-editor-2">Choosing your editor</a></h2>
<p>Whatever editor you choose, the goal is for you to have RLS and Code Formating (rustfmt) installed and enabled. VSCode is a mature and populare solution for Rust, but Vim is usable as well.</p>
<h3 id="configuring-vim-8x-for-rust-with-the-rls"><a class="header" href="#configuring-vim-8x-for-rust-with-the-rls">Configuring vim 8.x for Rust with the RLS</a></h3>
<p>The steps below configure vim 8.x to support Rust and use the Rust Language Server (RLS) for autocompletion.</p>
<ol>
<li>Make sure you have a working Git installation</li>
<li>Visit <a href="https://rls.booyaa.wtf">https://rls.booyaa.wtf</a> and follow the steps for your preferred Vim package management strategy.</li>
<li>Modify your vimrc to include the below snippet. The guide linked in the previous step is still configured to use the Rust nightly build, since the RLS used to only be available in the nightly builds. RLS is now available in stable, and we installed stable Rust (the default). The below snippet should replace the one from the linked guide, and changes the 'cmd' to use stable instead of nightly.</li>
</ol>
<pre><code class="language-text">if executable('rls')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'rls',
        \ 'cmd': {server_info-&gt;['rustup', 'run', 'stable', 'rls']},
        \ 'whitelist': ['rust'],
        \ })
endif
</code></pre>
<ol start="4">
<li>
<p>Make sure <code>filetype plugin indent on</code> and <code>syntax enable</code> and lets add format on save as well like <code>let g:rustfmt_autosave = 1</code></p>
</li>
<li>
<p>Restart vim or reload your vimrc</p>
</li>
<li>
<p>Open a Rust file and test our autocompletion (for example start typing <code>use std::</code>)</p>
<p><img src="./images/install/gvimrls.png" alt="vim Rust autocompletion" /></p>
</li>
</ol>
<h3 id="configuring-vs-code-for-rust-with-the-rls-2"><a class="header" href="#configuring-vs-code-for-rust-with-the-rls-2">Configuring VS Code for Rust with the RLS</a></h3>
<p>The steps below configure VS Code on Mac to support Rust and use the Rust Language Server (RLS) for autocompletion and incremental compilation to display warnings and errors.</p>
<ol>
<li>
<p>Install the Rust (rls) extension by user 'rust-lang' in VS Code. There are several other plugins, but this one is the most maintained.</p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>If you see an error message that the RLS could not be started or that the extension could not find rustup, then you will have to configure VS Code's path for rustup:</p>
<ol>
<li>
<p>Open VS Code preferences and navigate to the Rust extension preferences</p>
</li>
<li>
<p>Modify the rustup path to use an absolute path to your installation: <code>C:\Users\&lt;username&gt;\.cargo\bin\rustup</code></p>
<p><img src="./images/install/vscode_rust.png" alt="VS Code rustup path" /></p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>You may see a prompt in the lower-right to install the RLS. If so, click yes.</p>
</li>
</ol>
</li>
<li>
<p>Open a Rust file and test out the RLS:</p>
<ol>
<li>Try autocompletion (for example start typing <code>use std::</code>) at the top of a file</li>
<li>Try the incremental compilation (for example <code>println!(&quot;Hello, world!&quot;) blah blah 42 42</code> should show an inline error)</li>
</ol>
<p><img src="./images/install/vscode_rust2.png" alt="VS Code Rust autocompletion and incremental compilation" /></p>
</li>
<li>
<p>Enable format on save in VScode settings. Code-&gt;Preferences-&gt;Settings-&gt;Text Editor-&gt;Formatting-&gt;Format On Save</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy"><a class="header" href="#anatomy">Anatomy</a></h1>
<p>We’ve got a few tools to get to know</p>
<ul>
<li>rustup - manage tools and versions of toolchains</li>
<li>rustc - rust compiler</li>
<li>cargo - manage modules locally and remotely and drives rustc</li>
</ul>
<p><strong>EXERCISE: Open a terminal and create a new package with <code>cargo new training</code> and go to that directory with <code>cd training</code></strong></p>
<p>Now we have a Cargo.toml which defines our project, not unlike a package.json if you're familiar with Node.js, it defines dependencies we're using and other project information:</p>
<pre><code class="language-toml">[package]
name = &quot;training&quot;
version = &quot;0.1.0&quot;
authors = [&quot;First Last&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>In src folder we have main.rs, a Rust file. In this case it generated a simple hello world.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>We're starting to get some syntax for you. Notice functions are denoted <code>fn</code>, we use semicolons to end expressions, and the exclamation after <code>println!()</code> means that is a function-like macro. We'll talk more about <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macros</a> later.</p>
<p>Generally we'll interact with the compiler via Cargo. Cargo drives the rustc compiler and linker all under the hood. We can <code>cargo build</code> or better yet <code>cargo run</code> and save ourselves a step:</p>
<pre><code class="language-bash">$ cargo run
   Compiling training v0.1.0 (/Users/firstlast/training)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `/Users/firstlast/.cache/target/debug/training`
Hello, world!
</code></pre>
<p>The default build directory is target, and by default we got a debug build</p>
<pre><code class="language-bash">$ ls target/debug/
build  examples  native  training.d
deps  incremental  training  training.dSYM
</code></pre>
<p>Note, we could run or debug that built asset directly:</p>
<pre><code class="language-bash">./target/debug/training
Hello, world!
</code></pre>
<p>Also note, we could have compiled this simple file with the rustc compiler directly</p>
<pre><code class="language-bash">$ rustc src/main.rs
$ ./main
Hello, world!
</code></pre>
<p>However in practice almost no projects are single files require merging multiple modules from within our project and without and thus Cargo is THE way we interact with Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>We’ve got all the datatypes you would expect but you might want to glance through the Rust book <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html">chapter on variables, functions, and control flow</a> just to update your mental models to Rust notation</p>
<p>We have signed and unsigned scalar types like u32 and i32 and we've got Strings. Variables are instantiated with let syntax, and notably are immutable by default.</p>
<p>The top of the <a href="https://doc.rust-lang.org/std/">Rust standard library page</a> has a search box. Entering String there we find <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from">std::string::String</a> with a bunch of example usage right there for us. You can edit those examples and run them right in your browser to confirm your understanding and even click the [src] link in the upper right corner and be taken straight to the Rust implementation.</p>
<blockquote>
<p>While you totally can thrash around on stack overflow, and we all do, there really is an authoritative source that you should check first.</p>
</blockquote>
<p>From that example we have our String constructor.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    let input_path = String::from(&quot;valve.png&quot;);
    println!(&quot;{:?}&quot;, input_path);
}
</code></pre></pre>
<p>First, note we don’t need to import anything (we call it <code>use</code>) to use this <code>String</code> type. A portion of the standard library is in our namespace automatically, which we call the <a href="https://doc.rust-lang.org/std/prelude/index.html">prelude</a>. Basically Rust puts <code>use std::prelude::v1::*;</code> at the top of your file and you get access to those members. By no means is everything in there, but a lot is, which is what kept you from explicitly writing <code>use std::string::String</code> at the top of your file in this case. The <code>println!</code> macro came from there as well. You don't have to for this tutorial, but if you wanted to install a cargo tool called <a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a> you could see the end result of your code with all macros and preludes included but before it has been optimized to machine code.</p>
<pre><code class="language-bash">$ cargo install cargo-expand
..
$ cargo expand
#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
fn main() {
    let input_path = String::from(&quot;valve.png&quot;);
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(
            &amp;[&quot;&quot;, &quot;\n&quot;],
            &amp;match (&amp;input_path,) {
                (arg0,) =&gt; [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)],
            },
        ));
    };
}
$
</code></pre>
<p>Also notice we didn't have to explicitly type our variable. What Rust <em>can</em> figure it out, <em>it will</em> and so its entirely idiomatic to omit type annotations. However if you or the compiler are having trouble or getting odd type errors, start annotating some of your types like to see if you can give the compiler a hand. Its also a great way to figure out what type you actually have in case you're not sure, let the compiler (or linter) tell you.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let input_path = String::from(&quot;valve.png&quot;);
    let output_path:String = String::from(&quot;valve_sobel.png&quot;);
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>So now how to print those variables to console.  In Rust our printf <code>%</code> formatting character is <code>{}</code>. Following the <code>println!()</code> documentation down the rabbit hole will send us to the <a href="https://doc.rust-lang.org/std/fmt/index.html">formatters section</a> page and we find all the formatters which you would expect like hex <code>{:x}</code>, binary <code>{:b}</code>, etc. We're going to focus on the 'empty' Display formatter <code>{}</code> for now which is a kind of a pretty printer in Rust. As long as whomever wrote our type implemented the Display pretty printer trait this will work great (cue ominous music).</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let input_path = String::from(&quot;valve.png&quot;);
    let output_path = String::from(&quot;valve_sobel.png&quot;);
    println!(&quot;{} {}&quot;, input_path, output_path);
}
</code></pre></pre>
<p>Running this we find that we do have a Display implementation for String and pretty printing results in rather clean output in this case:</p>
<pre><code class="language-text">valve.png valve_sobel.png
</code></pre>
<p>Objects, we call them structs, should be very familiar. You can define a new struct in any scope you like and we can name and type their members.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Opt {
    input_path: String,
    output_path: String,
}

fn main() {

    let options = Opt {
        input_path: String::from(&quot;valve.png&quot;),
        output_path: String::from(&quot;valve_sobel.png&quot;),
    };

    println!(&quot;{} {}&quot;, options.input_path, options.output_path);
}
</code></pre></pre>
<p><strong>EXERCISE: Get this all implemented in your training project.</strong></p>
<p>Notice we access our struct members with dot notation, and there is no default new constructor or overloading in Rust. Though in practice, for functions where it makes sense many developers will offer and occasionally make their struct private to require the usage of a new or other constructor. So note, <code>String::new()</code> totally exists and would have made you an empty string.</p>
<p>Lets start modularizing our main by putting our options creation in a function. Function syntax is just like we see in the main function, but can return an expression from a function by leaving off the semicolon and annotating the return type.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Opt {
    input_path: String,
    output_path: String,
}

fn options() -&gt; Opt {

    let options = Opt {
        input_path: String::from(&quot;valve.png&quot;),
        output_path: String::from(&quot;valve_sobel.png&quot;),
    };
    return options;
}

fn main() {
    let options = options();
    println!(&quot;{} {}&quot;, options.input_path, options.output_path);
}
</code></pre></pre>
<p>We use semicolons to end expressions. We prefer to leave off semicolons in order to implicitly return the expression saving us the temporary variable like so.</p>
<pre><code class="language-rust ignore no_run">fn options() -&gt; Opt {

    Opt {
        input_path: String::from(&quot;valve.png&quot;),
        output_path: String::from(&quot;valve_sobel.png&quot;),
    }
}
</code></pre>
<p><strong>EXERCISE: Implement the <code>options()</code> function to clean up your main.</strong></p>
<p>But what if our options creation could fail? Lets talk about error handling in rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-and-result"><a class="header" href="#option-and-result">Option and Result</a></h1>
<p>Let's take our config options from the command line with runtime args instead of hard coding it at compile time. Search the standard library for <a href="https://doc.rust-lang.org/std/env/fn.args.html">args</a> finds args come in as a iterator of a collection. We'll talk about iterators later, but for now we can for loop over them, or get the <code>nth()</code> value. Just like C command line args the 0th argument is the name of the binary and the rest are your arguments.</p>
<pre><code class="language-rust ignore no_run">use std::env; // explicit use (import) finally

fn options() -&gt; Opt {

    Opt {
        input_path: env::args().nth(1).unwrap(),
        output_path: env::args().nth(2).unwrap(),
    }
}
</code></pre>
<p>And then note you can pass args around cargo to the binary were trying to run like:</p>
<pre><code class="language-bash">$ cargo run -- valve.png valve_sobel.png
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/training valve.png valve_sobel.png `
target/debug/training
valve.png
valve_sobel.png
</code></pre>
<p>So what is this unwrap. The problem is the nth argument may or may not be there...</p>
<p>We have two related types commingled in <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">error handling</a> in Rust.</p>
<p>Rust doesn’t have exceptions, but rather the <a href="https://doc.rust-lang.org/std/result/index.html">Result type</a> which can be used to propagate either the error or the result and looks like this:
<img src="./images/result.png" alt="Result Type" /></p>
<p>And Rust doesn't have Null but rather the <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option type</a> which can be used to propagate either the value (Some), or the lack of one (None)
<img src="./images/option.png" alt="Option Type" /></p>
<p>Were going to skip Result here, as our <code>nth()</code> method returns an Option, but they’re very similar in how they’re handled as they’re both implemented as enums. We basically have three possibilities for dealing with both:</p>
<h2 id="option-1-panic-unwrap-and-expect"><a class="header" href="#option-1-panic-unwrap-and-expect">Option 1, panic! unwrap and expect</a></h2>
<p>There <em>is</em> a minimal runtime in Rust, which means if were not careful we can and will blow up at runtime. This is called a panic and is handled in the panic handler, which on hosted platforms includes unwinding and backtraces. You can fire it on purpose with <code>panic!()</code> or by <code>unwrap()</code> on a None or Err value.</p>
<p><strong>EXERCISE: Run our program again, this time not passing any command line arguments.</strong></p>
<pre><code class="language-text">thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:347:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Explicitly panicing like we see above may very well be an option when the error is unrecoverable anyway like in examples like this where theres nothing intelligent we can do except maybe try to print a decent error message. If the error message needs help well often well use <code>.expect(&quot;Please enter an image file as the first option to this program&quot;)</code> instead of <code>unwrap()</code> in order to further refine the message.</p>
<h2 id="option-2-return-it"><a class="header" href="#option-2-return-it">Option 2, return it</a></h2>
<p>Another option is to make it someone else’s problem by simply handing the Option or Result back up the chain.</p>
<p>Theres even an early return helper for this, the <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">? operator</a>. This was previously the <a href="https://doc.rust-lang.org/std/macro.try.html">try! macro</a> but that has been deprecated though you may still see it in code.</p>
<p>Our <code>nth()</code> is an Option of Some or None so lets just hand an optional back up the chain to our main function. At least this way we can decide what to do with it there.</p>
<pre><code class="language-rust ignore no_run">fn options() -&gt; Option&lt;Opt&gt; { //&lt;-return Option wrapping our Opt struct

    Some(Opt { //&lt;-Now we wrap our good return in Some
        input_path: env::args().nth(1)?, //&lt;-unwrap becomes ? early return of None
        output_path: env::args().nth(2)?, //&lt;-unwrap becomes ? early return of None
    })
}
</code></pre>
<p><strong>EXERCISE: Have our options function return an Option of Opt.</strong></p>
<p>But we still get an error up in main now.</p>
<pre><code class="language-text">error[E0609]: no field `input_path` on type `std::option::Option&lt;Opt&gt;`
  --&gt; src/main.rs:93:44
</code></pre>
<p>Were passing an Option back to main, but now we need to deal with it there</p>
<h2 id="option-3-handle-it"><a class="header" href="#option-3-handle-it">option 3, handle it</a></h2>
<p>Someone has to do some control flow on this error somewhere.. Well thats actually not true, we can even return these from the main function where Rust will unwrap them behind the scenes and print the result, but generally if you can do control flow on your errors you should.</p>
<p>We often will often match Options and Results with the <a href="https://doc.rust-lang.org/rust-by-example/flow_control/match.html">match pattern</a> which is very similar to an exhaustive switch statement.</p>
<p>These two solutions are equivalent as they both panic if we don't get a good value. However you can easily see how you will be using match if you need to take some positive action on bad values.</p>
<pre><code class="language-rust ignore no_run">let options = options().unwrap();

println!(&quot;{} {}&quot;, options.input_path, options.output_path);
</code></pre>
<pre><code class="language-rust ignore no_run">let options = match options() {
    Some(val) =&gt; val,
    None =&gt; panic!(&quot;Please enter an image file as the first option to this program&quot;),
};

println!(&quot;{} {}&quot;, options.input_path, options.output_path);
</code></pre>
<p><strong>EXERCISE: Implement one of these solutions to satisfy the Rust compiler.</strong></p>
<p>The Option type is actually an enum type so we lets take a full digression through enums and matching in the next section.</p>
<h2 id="error-handling-playground"><a class="header" href="#error-handling-playground">error handling playground</a></h2>
<p>Its worth spending some time in the option result playground here to get your mind around all this.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::ErrorKind;

fn main() {
    // lets just make some values we might have gotten back from a function call
    let first_arg = Some(&quot;valve.png&quot;);
    let second_arg: Option&lt;String&gt; = None;
    let good_val: Result&lt;u32, std::io::ErrorKind&gt; = Ok(22);
    let definitely_error: Result&lt;u32, std::io::ErrorKind&gt; = Err(ErrorKind::Other);

    // Use unwrap to get access to the underlying value
    println!(&quot;{:?}&quot;, first_arg.unwrap());
    println!(&quot;{:?}&quot;, good_val.unwrap());
    // println!(&quot;{:?}&quot;, second_arg.unwrap()); //no good

    match first_arg {
        // this is the one that will match, as first_arg is a Some
        Some(val) =&gt; println!(&quot;first_arg: {}&quot;, val),
        // we dont get here for this program
        None =&gt; { // &lt;- Note the block scope here so we can have more expressions
            println!(&quot;what the&quot;);
            panic!(&quot;oops&quot;);
        }
    }

    // as we've said, results are very similar, just two different variants
    match definitely_error {
        // this is the one that will match, as definitely_error is an Err
        Err(e) =&gt; println!(&quot;{:?}&quot;, e),
        // we dont get here for this program
        Ok(val) =&gt; println!(&quot;cant imagine how we got here: {}&quot;, val),
    };

    // the revealing/destructuring pattern is really handy occasionally
    if let Some(val) = first_arg {
        println!(&quot;Gotem {:?}!&quot;, val);
    }

    // theres also a ton of combinators in the standard library
    // lets say we didnt care about the value, but wanted to check the success
    if good_val.is_ok() &amp;&amp; definitely_error.is_err() {
        println!(&quot;some convoluted example here&quot;);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-dependencies-cratesio"><a class="header" href="#external-dependencies-cratesio">external dependencies, crates.io</a></h1>
<p>Lets have our code load in an image from the filesystem. Searching in the standard library for images doesn't find anything, we could take a File to binary, but lets go to the community ecosystem, <a href="https://www.crates.io">crates.io</a>. Searching there for images finds a crate image with ~1mil downloads which seems to be pretty popular. <a href="https://crates.io/crates/image">image</a> says it wants us to add it to our Cargo.toml dependencies section so lets do that.</p>
<pre><code class="language-toml">[dependencies]
image = &quot;0.22.1&quot;
</code></pre>
<p>The <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-version-field">Cargo toml manifest version field</a> we learn Cargo uses <a href="https://semver.org">semantic versioning</a> which allows us to version and lock dependencies at the level of risk were comfortable with. From the spec:</p>
<pre><code class="language-text">Given a version number MAJOR.MINOR.PATCH, increment the:

MAJOR version when you make incompatible API changes,
MINOR version when you add functionality in a backwards compatible manner, and
PATCH version when you make backwards compatible bug fixes.
</code></pre>
<p>The <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo chapter on dependencies</a> explains more how to do this locking. The three digit version we used above is the same as a <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#caret-requirements">caret requirement</a> as if we had type <code>image = &quot;^0.22.1&quot;</code>. With this requirement Cargo is allowed to use any version it can satisfy between the range <code>&gt;=0.22.1 &lt;0.3.0</code> Semver works different below and above 1.0 with the idea that theres more breaking churn below 1.0. So for a fictional <code>image = &quot;^1.2.3&quot;</code> Cargo would be allowed to find patches <code>&gt;=1.2.3 &lt;2.0.0</code>. Refer to the spec and the book for many more clarifying examples.</p>
<h2 id="loading-the-input-image"><a class="header" href="#loading-the-input-image">Loading the input image</a></h2>
<p>Now in main.rs we can use this dependency. To start, let's just write the input to the output, passthrough, using the image create we looked at earlier.</p>
<pre><code class="language-rust ignore">use image;

let options = options().expect(&quot;Failed to parse command options!&quot;);

let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

input_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<blockquote>
<p>Repeatedly using the same variable name, called shadowing, is often even encouraged, as it means less messy temporary variables.</p>
</blockquote>
<h2 id="converting-to-grayscale-or-luma"><a class="header" href="#converting-to-grayscale-or-luma">Converting to grayscale (or luma)</a></h2>
<p>In our next section we're going to need an image in grayscale, with one value per pixel. Converting an RGB image to grayscale requires specific weights per component, but luckily the image create already implements this for us. We just need to figure out how to use it. Let's take a look at the docs again.</p>
<p><img src="./images/image-load-doc.png" alt="image::load docs" /></p>
<h3 id="to_luma-method"><a class="header" href="#to_luma-method">to_luma() method</a></h3>
<p>From looking at the <a href="https://docs.rs/image/0.22.1/image/enum.DynamicImage.html#method.to_luma">docs</a> on <code>image::open</code> we now know that it returns a <code>DynamicImage</code> type. If we peek at the <code>DynamicImage</code> docs we'll find a function called <code>to_luma()</code>, which is exactly what we want. Notice it returns a different type, <code>GrayImage</code>.</p>
<p>Since types and abstractions in Rust don't incur overhead, it's pretty typically to use more types than less to represent different possible data structures and formats. This not only makes code clear to the reader, but also allows the compiler to help you enforce invariants.</p>
<p>For example, we can make our processing code later only accept <code>GrayImage</code> as input, which makes sure the caller has converted any inputs.</p>
<p><img src="./images/to_luma.png" alt="to_luma method" /></p>
<pre><code class="language-rust ignore">let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

let input_image = input_image.to_luma();

input_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>The borrow checker is probably Rust's most distinctive feature. To enable zero cost abstractions, Rust does not have a garbage collector. However, Rust also doesn't rely on explicit calls to <code>free()</code> like C. Instead Rust enforces &quot;ownership&quot; for all memory objects. The rules of the ownership system are pretty simple:</p>
<ol>
<li>
<p>There is only ever one owner of a memory object at a time (struct, enum, primitive, etc)</p>
</li>
<li>
<p>Immutable (read-only) ownership can be borrowed multiple places simultaneously</p>
</li>
<li>
<p>Mutable (writable) ownership can only be borrowed once at a time and exclusively</p>
</li>
<li>
<p>An object must live at least as long as all of its borrows</p>
</li>
</ol>
<h2 id="rule-1-single-owner"><a class="header" href="#rule-1-single-owner">Rule #1: single owner</a></h2>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn eat(s: String) {
    println!(&quot;Eating {}&quot;, s);
}

fn main() {
    let food = String::from(&quot;salad&quot;);
    eat(food);
    eat(food);
}
</code></pre></pre>
<p>The compiler error tells us exactly what's wrong. The <code>fn eat(s: String)</code> signature says that <code>s</code> will be moved into the function upon calling. In other words, the function <code>eat</code> will take ownership of <code>s</code>. Unless we pass ownership back to the caller, ownership will remain there. This is called &quot;consuming&quot; a parameter.</p>
<p>Here's how we can pass ownership back.</p>
<pre><pre class="playground"><code class="language-rust editable">fn eat(s: String) -&gt; String {
    println!(&quot;Eating {}&quot;, s);
    s
}

fn main() {
    let food = String::from(&quot;salad&quot;);
    let owned_food = eat(food);
    eat(owned_food);
}
</code></pre></pre>
<h2 id="rule-2-multiple-immutable-borrows"><a class="header" href="#rule-2-multiple-immutable-borrows">Rule #2: multiple immutable borrows</a></h2>
<p>If we change the function signature to borrow <code>s</code> instead, the problem goes away.</p>
<pre><pre class="playground"><code class="language-rust editable">fn stare_at(s: &amp;String) {
    println!(&quot;Drooling over {}&quot;, s);
}

fn main() {
    let food = String::from(&quot;donut&quot;);
    let another_ref = &amp;food;
    stare_at(&amp;food);
    stare_at(&amp;food);
    stare_at(another_ref);
}
</code></pre></pre>
<h2 id="rule-3-mutable-borrows-are-exclusive"><a class="header" href="#rule-3-mutable-borrows-are-exclusive">Rule #3: mutable borrows are exclusive</a></h2>
<p>Only a mutable borrow for an object can exist at a time. This prevents many subtle errors where internal state is mutated while other does not expect it. In C++, modifying a container while iterating through it is a classic example.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut number: usize = 32;

    let borrowed = &amp;number;
    println!(&quot;Borrowed: {}&quot;, borrowed);

    let mut_borrowed = &amp;mut number;
    *mut_borrowed = 59;
    println!(&quot;Mut borrowed: {}&quot;, mut_borrowed);
    println!(&quot;Borrowed: {}&quot;, borrowed);
}
</code></pre></pre>
<p>You'll notice the compiler gave us an error because we have an immutable borrow out there when we try to mutably borrow number. Any additional borrows, mutable or not, will make a mutable borrow invalid.</p>
<p>When we have an exclusive mutable borrow, all is good.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut number: usize = 32;

    let mut_borrowed = &amp;mut number;
    *mut_borrowed = 59;
    println!(&quot;Mut borrowed: {}&quot;, mut_borrowed);
}
</code></pre></pre>
<h2 id="rule-4-lifetime--borrow-time"><a class="header" href="#rule-4-lifetime--borrow-time">Rule #4: lifetime &gt;= borrow time</a></h2>
<p>In the example below, we borrow a temporary value inside the if statement branches. The temporary value does not last beyond the if statement branch, so the compiler tells us that our borrow is invalid. We can't borrow an object that doesn't exist.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let borrowed = if 1 + 1 == 2 {
        let msg = &quot;The world is sane.&quot;;
        &amp;msg
    } else {
        let msg = &quot;The world is insane!&quot;;
        &amp;msg
    };
}
</code></pre></pre>
<h2 id="the-learning-curve"><a class="header" href="#the-learning-curve">The learning curve</a></h2>
<p>Many new Rustaceans report that the fighting the borrow checker is the hardest part of learning Rust, and kind of like hitting a wall. Programmers coming from C/C++ tend to have a hard time because they know exactly what they want to do, but the Rust compiler &quot;won't let them do it&quot;.</p>
<p>Over time, the borrowing rules and working with the borrow checker become second nature. In fact, the borrow checker enforces rules that well-written C++ code should abide by anyway. Working with the borrow checker is kind of like pair programming with a memory ownership expert.</p>
<p>The borrowing rules prevent all kinds of common C++ memory and security errors. For example, you can't create a dangling borrow, the compiler won't let you. In C/C++, you can quite easily create a dangling pointer!</p>
<h2 id="cloning"><a class="header" href="#cloning">Cloning</a></h2>
<p>While you are learning Rust, you will face another temptation: clone everything! The <code>Clone</code> trait in Rust provides the method <code>clone()</code> which creates a copy of any objects that implements <code>Clone</code>. When something is cloned, the borrows on the original do not apply to the new copy.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut number: usize = 32;

    let cloned = number.clone();
    println!(&quot;Cloned: {}&quot;, cloned);

    let mut_borrowed = &amp;mut number;
    *mut_borrowed = 59;
    println!(&quot;Mut borrowed: {}&quot;, mut_borrowed);
    println!(&quot;Cloned: {}&quot;, cloned);
}
</code></pre></pre>
<h2 id="lifetimes-and-scopes"><a class="header" href="#lifetimes-and-scopes">Lifetimes and scopes</a></h2>
<p>One last thing to note about lifetimes is that they are tied to scopes. So a borrow must exist in a scope at or below the level of the ownership.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut number: usize = 32;
    {
        let borrowed = &amp;number; // works!
        println!(&quot;It works: {}&quot;, borrowed);
    }

    {
        let number2: usize = 64;
    }
    let borrowed2 = &amp;number2; // fails!
}
</code></pre></pre>
<p>Also, Rust allows a scope to return a value. This is useful for temporarily borrowing a value in a limited scope and computing some value without creating a whole separate function for it.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number: usize = 32;
    let new_number = {
        let borrowed = &amp;number;
        borrowed + 16
    };
    println!(&quot;{}&quot;, new_number);
}
</code></pre></pre>
<p>Prior to Rust 2018 edition, it used to be common to use scopes to explicitly end borrows. The below code shows how we can use an extra scope (curly braces) to end a borrow early to allow a mutable borrow. With Rust 2018, the compiler is actually smart enough to detect this on its own, so we don't worry about it much unless you have a specific case the compiler can't figure out.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut number: usize = 32;

    {
        let borrowed = &amp;number;
        println!(&quot;Borrowed: {}&quot;, borrowed);
    } // borrow ends here

    // no living borrows, so &amp;mut is ok!
    let mut_borrowed = &amp;mut number;
    *mut_borrowed = 59;
    println!(&quot;Mut borrowed: {}&quot;, mut_borrowed);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)">Convolving a kernel with an image</a> is an incredibly common operation in all kinds of image processing. With it we can implement all the machine learning greatest hits, which for images as you can see includes <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Details">edge detection sharpen, blur and more</a>. Convolution should remind you of Convolution Neural nets and might give you an idea how those work too.</p>
<p>To convolve, we multiply each element in the data (lets say pixels) with the corresponding value in the kernel matrix and then add up all the results.
<img src="./images/convolution.png" alt="convolution process" /></p>
<p>Lets do a little test driven development in order to show off Rust's built in testing capability. So we need 2 sets of data, a kernel to convolve on our data, and some data (lets think of it as pixels). These kernels have been developed over the years in papers and are largely just avialable to copy. Did you notice the Identity Kernel on the page? That kernel, when convolved on data, simply returns back the original data unchanged. That would be an easy test to write.</p>
<p>We can define the data in many structures including Vecs, Arrays, or a math library might offer a Matrix type of some kind. Looking at the identity kernel we need a 3x3 set of floats. For now let's use a fixed size array of fixed size arrays. This preserves the row and column structure of the kernels. We'll use the const keyword to define these as constant, static data outside of any function. The compiler will not let us in any way mutate this data.</p>
<pre><code class="language-rust ignore">const IDENTITY: [[f32; 3]; 3] = [
    [0.0, 0.0, 0.0],
    [0.0, 1.0, 0.0],
    [0.0, 0.0, 0.0]
];
</code></pre>
<p>Now we need some test data to convolve with our identity. When we convolve we're looking at the value of interest, generally the center value, but we also take with it some amount of its nearby values in order to let those effect the value we care about. This is the value were 'convolving' around. Lets just make up a fake set of pixels, 1.0 through 9.0 where the value of interest is thus <code>5.0</code>.</p>
<pre><code class="language-rust ignore">let pixels: [[f32; 3]; 3] = [
    [1.0, 2.0, 3.0],
    [4.0, 5.0, 6.0],
    [7.0, 8.0, 9.0]
];
</code></pre>
<p>We need a convolve function that takes the kernel we want to convolve around the data. We could jump in and try and write the whole thing but lets procrastinate a bit more. We need our function to have 2 arguments, the kernel and the pixel data, and we probably don't want to consume them as we might want to use them in another function so lets take borrows of those as our arguments. Further if we run the convolve steps we previously discussed above by hand, you'd expect the identity, which doesnt change our value of interest, to just return the value in this case 5.0 so let's hardcode that.</p>
<pre><code class="language-rust ignore">fn convolve(kernel: &amp;[[f32; 3]; 3], pixels: &amp;[[f32; 3]; 3]) -&gt; f32 {
    5.0
}
</code></pre>
<p>Now we can write a test to assert that running <code>convolve()</code> indeed does return 5.0.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_convolution_identity() {
        let pixels: [[f32; 3]; 3] = [
            [1.0, 2.0, 3.0],
            [4.0, 5.0, 6.0],
            [7.0, 8.0, 9.0]
        ];
        assert_eq!(convolve(&amp;IDENTITY, &amp;pixels), 5.0);
    }
}
</code></pre>
<p>We can run this test with <code>cargo test</code> and we should see passing tests!</p>
<p>We'll come back to implmenting our convolve function for real in a second, but we'll need a few more tools in our toolbox so first we learn how to iterate over these arrays and multiply them using iterators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>Iterators are one of the most powerful features in Rust! They are also a gateway drug to the functional style programming. They tend to use less memory and optimize better because the compiler can see what we're trying to do and help optimize for us. This gain in speed and reduced memory usage is really important for big datasets or constrained devices where it might be literally impossible to have the entire collection in memory at the same time.</p>
<p>Most collections like an array can be iterated which just means getting the collection one element at a time. This imperitive style use of an iterator should look very familiar to you. Well just print each value.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];

    for i in array.iter() {
        println!(&quot;{:?}&quot;, i);
    }
}
</code></pre></pre>
<p>One of the benefits of using iterators is all the functions we get for free. These are generally called 'combinators' but thats just a fancy name for a function that we can run against our collection. The Rust standard library provides a <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">large selection</a> of combinators for use with iterators from summing, to sorting to reversing data and much much more.</p>
<p>Lets reverse our array with <code>rev()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];
    for i in array.iter().rev() {
        println!(&quot;{:?}&quot;, i);
    }
}
</code></pre></pre>
<p>If we wanted to do some custom logic like add, we could certainly do it in the for loop.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];

    for i in array.iter() {
        let val = i + 1.0;
        println!(&quot;{:?}&quot;, val);
    }
}
</code></pre></pre>
<p>But thats not very functional. If we keep this up were just back at the imperitive style. Lets look at the <code>map</code> combinator instead. It lets us define a function to be run on each element one at a time, and we'll do our addition there instead. This way we can seperate concerns keeping our functions single which also has the benefit in that compiler can see better what we're doing so it can optimize better.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];
    for i in array.iter().map(|i| { i + 1.0 } ) { // &lt;- Note no semicolon, we're returning the result of our addition. Also the rust formatter will remove these uneeded brackets are needed as its only a single expression
        println!(&quot;{:?}&quot;, i);
    }
}
</code></pre></pre>
<p>Ok now lets add AND reverse.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];
    for i in array.iter().rev().map(|i| i + 1.0) {
        println!(&quot;{:?}&quot;, i);
    }
}
</code></pre></pre>
<p>Very slick. How many times have you come across a for loop that you have to puzzle over for 10 minutes to understand what 5 things its doing at the same time? Chained combinators are very self documenting, because they all have names and can be read in order. Plus by not reimplementing simple functions, you don't reimplement the bugs either. Future you thanks present you.</p>
<p>Lets get even a little bit more functional. If instead of just for looping we assign the iterator to a value, we can hold the intermediate iterator and reuse it or pass it to functions.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];
    let reversed_and_elevated = array.iter().rev().map(|i| i + 1.0);
    println!(&quot;{:?}&quot;, reversed_and_elevated);
}
</code></pre></pre>
<p>Interesting. This time it didn't print our end result, but rather printed the chain of mutations plus the original data <code>Map { iter: Rev { iter: Iter([22.0, 1.0, 17.0]) } }</code>. It turns out iterators are 'lazily evaluated' which means theyre not actuall run until they're consumed. The <code>for in</code> loop and the <code>.sum()</code> are operations we have previously seen that consume an iterator. Another function that consumes an iterator is <code>collect()</code> which collects all the values back into a whole new array.</p>
<p>We actually can't collect into <code>Array</code> data structures (yet). Instead we'll use a <code>Vec</code> which we won't go over much here yet, but its just another collection type that is a bit more costly and powerful than arrays.</p>
<blockquote>
<p>NOTE: This is actually the costly thing we've been avoiding all this time. It brings all the values back into memory and can take lots of memory and compute time. For debugging, desktop programming and small datasets its totally fine and eventually often you just need to consume and get back to an <code>Vec</code>. However when you move to the optimizing stage, or if you're running on constrained devices, you're looking to remove as many <code>collect()</code> as possible and just keep chaining iterators.</p>
</blockquote>
<p>So lets collect our iterator and print the result. The compiler often has trouble knowing what you're trying to collect to so we'll help it out with a type hint.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];
    let reversed_and_elevated = array.iter().rev().map(|i| i + 1.0);
     // We `clone` the iterator which is cheap, its not copying the datastructure just our mutation chain
    let reversed_and_elevated_array: Vec&lt;f64&gt; = reversed_and_elevated.clone().collect();
    println!(&quot;{:?}&quot;, reversed_and_elevated_array);
    
    // Now we can use it again or pass it to another function, or add more combinators. Note we didn't need to clone it this time since we don't use it again in this example, but we could.
    let un_reversed_and_elevated_array: Vec&lt;f64&gt; = reversed_and_elevated.rev().collect();  
    println!(&quot;{:?}&quot;, un_reversed_and_elevated_array);
}
</code></pre></pre>
<p>To show what lazily evaluated means, run this example with no collect or for loop.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [22.0, 1.0, 17.0];
    array.iter().rev().map(|i| {
        println!(&quot;{:?}&quot;, i);
        i + 1.0
    });
}
</code></pre></pre>
<p>Note that nothing was printed because the <code>map()</code> wasn't actually run. The playground probably lost the warning, but if you do accidently run this code on your machine, the compiiler has your back with the following warning.</p>
<pre><code class="language-text">warning: unused `Map` that must be used
 --&gt; src/main.rs:3:5
  |
3 |     array.iter().rev().map(|i| i + 1.0);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: 1 warning emitted
</code></pre>
<p>It gets a little more complex from here but were going to need a few more tools as we continue. <code>zip()</code> combines one value from each of two different iterators into a tuple like <code>(22.0, 4.0)</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array1 = [22.0, 1.0, 17.0];
    let array2 = [4.0, 19.0, 6.0];

    // you might want print in the map so you can better understand the (i,j) tuple
    let zipped = array1.iter().zip(array2.iter()).map(|(i, j)| i + j);
    let summed_array: Vec&lt;f64&gt; = zipped.collect();
    println!(&quot;{:?}&quot;, summed_array);
}
</code></pre></pre>
<p><code>flatten()</code> iterates through iterators like n dimensional structures and concatenates them one after the other, or &quot;flattens&quot; them. If we had a two dimensional array of arrays and wanted to turn it into a single flat array we would use <code>flatten()</code>. One more trick is needed here, our iterator is pointing at borrowed references to the arrays. We need to use <code>cloned()</code> on our iterator in order to turn our <code>&amp;f32</code> values in <code>f32</code>. If we run this without the compiler says &quot;value of type <code>Vec&lt;f32&gt;</code> cannot be built from `std::iter::Iterator&lt;Item=&amp;f32&gt;&quot;</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array: [[f32; 3]; 3] = [
            [1.0, 2.0, 3.0],
            [4.0, 5.0, 6.0],
            [7.0, 8.0, 9.0]
    ];
    println!(&quot;{:?}&quot;, array);

    let flat_array: Vec&lt;f32&gt; = array.iter().cloned().flatten().collect();
    println!(&quot;{:?}&quot;, flat_array);
}
</code></pre></pre>
<p>Finally if we wanted to both <code>flatten()</code> and <code>map()</code> at the same time we can use <code>flat_map()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array: [[f32; 3]; 3] = [
            [1.0, 2.0, 3.0],
            [4.0, 5.0, 6.0],
            [7.0, 8.0, 9.0]
        ];
    println!(&quot;{:?}&quot;, array);

    let flat_mapped_array: Vec&lt;f32&gt; = array.iter().flat_map(|i| {
        // each i is an entire row of the array, it hasn't been flattened yet
        println!(&quot;{:?}&quot;, i);
        // we could do something complex but well just print the inner elements
        i.iter().cloned().map(|j| {
            println!(&quot;{:?}&quot;, j); 
            j
        })
    }).collect();
    println!(&quot;{:?}&quot;, flat_mapped_array);
}
</code></pre></pre>
<p>Thats all we'll need for our convolution for now, but if you want even more combinators, checkout the <a href="https://docs.rs/itertools/0.8.0/itertools/">itertools</a> crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convolution"><a class="header" href="#convolution">Convolution</a></h1>
<p>With what you now know about iterators, lets revisit our <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution">Convolution operator</a></p>
<p>If you'll remember we left you with stubbed test.</p>
<pre><code class="language-rust ignore">fn convolve(kernel: &amp;[[f32; 3]; 3], pixels: &amp;[[f32; 3]; 3]) -&gt; f32 {
    5.0
}
</code></pre>
<p><strong>Exercise: Finish out the convolve function we stubbed earlier. You'll need everything we went through on the iterators page so head back there and think hard on how you can create an iterator from both pixels and kernel, multiply each element of each matrix and return the sum of the results.</strong></p>
<blockquote>
<p>Note rust doesn't show println data from tests, so use <code>cargo test -- --nocapture</code> to see your println debugging in this case.</p>
</blockquote>
<details><summary>Uncollapse for a hint. But try first!</summary>
<p>
<p>Here we use <code>zip()</code> to combine two iterators into one iterator that yields tuple elements. Since kernel and pixels are nested arrays, <code>kernel.iter()</code> and <code>pixels.iter()</code> both give iterators over elements of type <code>[f32; 3]</code>. So, the tuple parameter <code>(kernel_col, input_col)</code> has type <code>([f32; 3], [f32; 3])</code>. Therefore in the closure, we iterate and zip once again, to yield elements of type <code>(f32, f32)</code> that we can multiply together. Finally we use the sum combinator to add all the products up.</p>
<details><summary>Uncollapse for the answer. But try first!</summary>
<p>
<pre><code class="language-rust ignore">    kernel
        .iter()
        .zip(pixels.iter())
        .flat_map(|(kernel_column, input_column)| {
            kernel_column
                .iter()
                .zip(input_column.iter())
                .map(|(k, p)| k * p)
        })
        .sum()
</code></pre>
</p>
</details>
</p>
</details>
<p>Ok now we have a working convolve function with an identity kernel, but we need our Sobel edge detection kernel instead now. The <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel Wikpedia</a> page shows we actually need two kernels, one each estimating the gradient ofs Gx and Gy. In an image, the gradient describes how fast the color of the image is changing in a direction, X and Y in this case. Typically, edges change very quickly, so if we output the gradient of the image, we expect the edges to have high values.</p>
<p>Copy in the kernel definitions to your code</p>
<pre><code class="language-rust ignore">/// Kernel for the Sobel operator in the X direction
const SOBEL_KERNEL_X: [[f32; 3]; 3] = [
    [-1.0, -2.0, -1.0],
    [0.0, 0.0, 0.0],
    [1.0, 2.0, 1.0]
];

/// Kernel for the Sobel operator in the Y direction
const SOBEL_KERNEL_Y: [[f32; 3]; 3] = [
    [-1.0, 0.0, 1.0],
    [-2.0, 0.0, 2.0],
    [-1.0, 0.0, 1.0]
];
</code></pre>
<p>And write another sanity test which if all is well should just pass!</p>
<pre><code class="language-rust ignore">    #[test]
    fn test_convolution_sobel() {
        let pixels: [[f32; 3]; 3] = [
            [1.0, 2.0, 3.0],
            [4.0, 5.0, 6.0],
            [7.0, 8.0, 9.0]
        ];
        assert_eq!(convolve(&amp;SOBEL_KERNEL_X, &amp;pixels), 24.0);
        assert_eq!(convolve(&amp;SOBEL_KERNEL_Y, &amp;pixels), 8.0);
    }
}
</code></pre>
<p>Next up lets get back to our real image data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-processing-example"><a class="header" href="#image-processing-example">Image Processing Example</a></h1>
<h2 id="getting-the-pixels"><a class="header" href="#getting-the-pixels">Getting the pixels</a></h2>
<p>Our convolution function is ready, but we are missing the connection between the image we converted to luma and the convolution operator. Let's look into the <a href="https://docs.rs/image/0.22.1/image/type.GrayImage.html">docs on GrayImage</a> to see how we can get pixel values out.</p>
<p><img src="./images/gray-image-docs.png" alt="GrayImage docs" /></p>
<p>At first glance, it doesn't look like there are many methods, huh?</p>
<p>Let's take a closer look. <code>GrayImage</code> is defined as a type alias of a specific variation of ImageBuffer (using generic type parameters). If we click on <code>ImageBuffer</code> (usually in Rust docs, you can click on a type name to see its docs), we will see the <a href="https://docs.rs/image/0.22.1/image/struct.ImageBuffer.html">full list of available methods</a>.</p>
<p><img src="./images/image-get-pixel-docs.png" alt="get_pixel docs" /></p>
<p>There's a <code>get_pixel</code> method! Oh, but the return type is <code>&amp;P</code>, that's weird. If we look at the declaration of ImageBuffer though, we see that <code>P</code> must implement the <code>Pixel</code> trait. And if we look at the <code>Pixel</code> <a href="https://docs.rs/image/0.22.1/image/trait.Pixel.html">trait docs</a>, we see a method called <code>channels()</code> that gives us a slice of the pixel's values, one for each channel. Since out image is grayscale (luma), we expect just one channel.</p>
<p>This might seem over-complicated. However, by abstracting away the underlying storage formats, the &quot;image&quot; crate lets users build processing systems that are general over many image formats. Remember, the Rust compiler boils down all of the abstractions into highly optimized code. So we can have our generics and safety while writing high-performance code!</p>
<p>For our case, we just have a GrayImage with pixels of type <code>Luma&lt;u8&gt;</code> that implement the <code>Pixel</code> trait. So we should be able to fetch a pixel pretty easily. Here's a go:</p>
<pre><code class="language-rust ignore">use image::Pixel; // trait for '.channels()'

let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

let input_image = input_image.to_luma();

println!(&quot;Pixel 0, 0: {}&quot;, input_image.get_pixel(0, 0).channels()[0]);

input_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<p>Generally, well-written Rust crates provide comprehensive types like this to cover the data formats and structures that they operate on. An image library in C/C++ may provide a raw buffer of pixels, which is easy to access. But, as soon as you have to deal with multiple formats, multiple pixel orderings (RGB, BGR, RGBA, etc.), it can be difficult to ensure all code branches are correct. With Rust, the type system will catch these errors at compile time.</p>
<p>Now that we can grab pixels, let's write a function that takes the pixel values and calls our convolution function. First we'll start with this signature, and copying the input. We need a place to store the resulting convolved pixel values, and we want an image of the same dimensions and data types. <code>clone()</code> is an easy way to get that. Notice that <code>result</code> is declared as <code>mut</code> since we will be modifying its contents.</p>
<pre><code class="language-rust ignore">use image::{GrayImage, Pixel};

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input.clone();

    result
}
</code></pre>
<p>To start with, let's just create the block of pixels to feed the convolution for each center pixel.</p>
<pre><code class="language-rust ignore">use image::{GrayImage, Pixel};

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input.clone();

    for x in 0..input.width() {
        for y in 0..input.height() {
            let pixels = [
                [
                    input.get_pixel(x - 1, y - 1).channels()[0],
                    input.get_pixel(x - 1, y).channels()[0],
                    input.get_pixel(x - 1, y + 1).channels()[0],
                ],
                [
                    input.get_pixel(x, y - 1).channels()[0],
                    input.get_pixel(x, y).channels()[0],
                    input.get_pixel(x, y + 1).channels()[0],
                ],
                [
                    input.get_pixel(x + 1, y - 1).channels()[0],
                    input.get_pixel(x + 1, y).channels()[0],
                    input.get_pixel(x + 1, y + 1).channels()[0],
                ],
            ];
        }
    }

    result
}
</code></pre>
<p>We'll need to throw a call into <code>fn main()</code> to use this.</p>
<pre><code class="language-rust ignore">let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

let input_image = input_image.to_luma();

let input_image = sobel_filter(&amp;input_image);

input_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<p>And then when we run this... what happened?!? What does it mean we attempted subtraction with overflow?</p>
<p>Well, in Rust debug builds, the primitive integer types are checked for overflows an underflows in the basic operations. Don't worry, these are not enabled in the release build unless you specifically want.</p>
<p>And, just like now, the overflow checks in debug builds help catch bugs early on.</p>
<h2 id="handling-the-edges"><a class="header" href="#handling-the-edges">Handling the edges</a></h2>
<p>The overflow is happening because of the <code>x - 1</code> and <code>y - 1</code> when x or y is zero. Remember, the kernel includes one pixel left, right, up and down from the one its currently operating on. When were on the far border of our image that pixel doesn't exist. This is indicative of a bigger question: how should we handle the edges of the image?</p>
<p>As the <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Edge_Handling">Wikipedia page on convolution kernels</a> explains, there are several ways:</p>
<ul>
<li>Extend the image by duplicating pixels at the edge</li>
<li>Wrap around to the other side</li>
<li>Crop the output image 2 pixels smaller in X and Y</li>
<li>Crop the kernel on the edges and corners</li>
</ul>
<p>If we crop the output image, we can easily adapt our code. The ImageBuffer struct implements the GenericImage trait which has a function called <code>sub_image</code> that gives us a view into rectangular section of an image. With a <code>SubImage</code> we can call <code>to_image()</code> to get a cropped <code>ImageBuffer</code> back out.</p>
<pre><code class="language-rust ignore">use image::{GenericImage, GrayImage, Pixel};

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input
        .sub_image(1, 1, input.width() - 2, input.height() - 2)
        .to_image();

    //start convolve in 1 pixel
    for x in 1..(input.width() - 1) {
        //start convolve in 1 pixel
        for y in 1..(input.height() - 1) {
            let pixels = [
                [
                    input.get_pixel(x - 1, y - 1).channels()[0],
                    input.get_pixel(x - 1, y).channels()[0],
                    input.get_pixel(x - 1, y + 1).channels()[0],
                ],
                [
                    input.get_pixel(x, y - 1).channels()[0],
                    input.get_pixel(x, y).channels()[0],
                    input.get_pixel(x, y + 1).channels()[0],
                ],
                [
                    input.get_pixel(x + 1, y - 1).channels()[0],
                    input.get_pixel(x + 1, y).channels()[0],
                    input.get_pixel(x + 1, y + 1).channels()[0],
                ],
            ];
        }
    }

    result
}
</code></pre>
<p>Oh, and did you find a place where clone might be handy?. Cool. No more overflows. We should get the convolution in there! Usually, we also divide by a constant value to &quot;normalize&quot; the result (really just make sure it is within the 0.0-1.0 range). For the Sobel operator on a 3x3 block of pixels, a divisor of 8.0 works well.</p>
<pre><code class="language-rust ignore">use image::{GenericImage, GrayImage, Pixel};

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input
        .clone()
        .sub_image(1, 1, input.width() - 2, input.height() - 2)
        .to_image();

    //start convolve in 1 pixel
    for x in 1..(input.width() - 1) {
        //start convolve in 1 pixel
        for y in 1..(input.height() - 1) {
            let pixels = [
                [
                    input.get_pixel(x - 1, y - 1).channels()[0],
                    input.get_pixel(x - 1, y).channels()[0],
                    input.get_pixel(x - 1, y + 1).channels()[0],
                ],
                [
                    input.get_pixel(x, y - 1).channels()[0],
                    input.get_pixel(x, y).channels()[0],
                    input.get_pixel(x, y + 1).channels()[0],
                ],
                [
                    input.get_pixel(x + 1, y - 1).channels()[0],
                    input.get_pixel(x + 1, y).channels()[0],
                    input.get_pixel(x + 1, y + 1).channels()[0],
                ],
            ];

            // normalize divisor of 8.0 for Sobel
            let gradient_x = convolve(&amp;SOBEL_KERNEL_X, &amp;pixels) / 8.0;
            let gradient_y = convolve(&amp;SOBEL_KERNEL_Y, &amp;pixels) / 8.0;
        }
    }

    result
}
</code></pre>
<p>Uh oh. Now we have a different problem. Our <code>GrayImage</code> gives us <code>u8</code> from <code>get_pixel(x, y).channels()[0]</code>, but <code>convolve()</code> expects the pixels to be f32.
We can explicitly cast that with 'as f32'.</p>
<p>We can also add a couple lines to combine our two kernels into a single magnitude with the sum of squares. Then well need to turn our resulting f32 into a u8 Luma type before storing it back into the resulting image.</p>
<pre><code class="language-rust ignore">use image::{GenericImage, GrayImage, Luma, Pixel};

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input
        .clone()
        .sub_image(1, 1, input.width() - 2, input.height() - 2)
        .to_image();

    //start convolve in 1 pixel
    for x in 1..(input.width() - 1) {
        //start convolve in 1 pixel
        for y in 1..input.height() - 1 {
            let pixels = [
                [
                    input.get_pixel(x - 1, y - 1).channels()[0] as f32,
                    input.get_pixel(x - 1, y).channels()[0] as f32,
                    input.get_pixel(x - 1, y + 1).channels()[0] as f32,
                ],
                [
                    input.get_pixel(x, y - 1).channels()[0] as f32,
                    input.get_pixel(x, y).channels()[0] as f32,
                    input.get_pixel(x, y + 1).channels()[0] as f32,
                ],
                [
                    input.get_pixel(x + 1, y - 1).channels()[0] as f32,
                    input.get_pixel(x + 1, y).channels()[0] as f32,
                    input.get_pixel(x + 1, y + 1).channels()[0] as f32,
                ],
            ];

            // normalize divisor of 8.0 for Sobel
            let gradient_x = convolve(&amp;SOBEL_KERNEL_X, &amp;pixels) / 8.0;
            let gradient_y = convolve(&amp;SOBEL_KERNEL_Y, &amp;pixels) / 8.0;
            let magnitude = (gradient_x.powi(2) + gradient_y.powi(2)).sqrt();
            //place our pixel off by one because of crop
            result.put_pixel(x - 1, y - 1, Luma([(magnitude) as u8]));
        }
    }

    result
}
</code></pre>
<p>Now if we <code>cargo run</code>, the output should be interesting. If the runtime is a bit long, you might try <code>cargo run --release</code>. Running in release mode can make a massive difference.</p>
<h2 id="sucess"><a class="header" href="#sucess">Sucess</a></h2>
<p><img src="./images/valve_sobel.png" alt="Result image" /></p>
<h2 id="extra-credit"><a class="header" href="#extra-credit">Extra credit</a></h2>
<ul>
<li>Can you implement edge extension instead of cropping?</li>
<li>Can you implement a box blur instead of the Sobel operator?</li>
<li>Can you extend the command line interface to allow the user to select what filter to apply?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arguments-libraries"><a class="header" href="#arguments-libraries">arguments libraries</a></h1>
<p>We could polish up this binary with some better command line argument parsing, error messages, version, etc, but if you were thinking someone else has to have done this type of work before, you'd be right. Theres a helper called <a href="https://crates.io/crates/structopt">structopt</a> that uses <a href="https://doc.rust-lang.org/stable/book/ch19-06-macros.html">macros</a> to annotate your existing struct.</p>
<pre><code class="language-rust ignore no_run">use std::path::PathBuf;
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
#[structopt(name = &quot;training&quot;)]
struct Opt {
    #[structopt(short = &quot;i&quot;, long = &quot;input&quot;, parse(from_os_str))]
    input_path: PathBuf,
    #[structopt(short = &quot;o&quot;, long = &quot;output&quot;, parse(from_os_str))]
    output_path: PathBuf,
}
</code></pre>
<p>Then not too much changes in our existing main.</p>
<pre><code class="language-rust ignore no_run">fn main() {
    let opt = Opt::from_args();
    println!(&quot;{:?}&quot;, opt);
}
</code></pre>
<p>Running <code>cargo run -- -i valve.png -o valve_sobel.png</code> results in</p>
<pre><code class="language-text">Opt { input_path: &quot;valve.png&quot;, output_path: &quot;valve_sobel.png&quot; }
</code></pre>
<p>and running <code>cargo run -- --help</code></p>
<pre><code class="language-text">training 0.1.0
First Last &lt;FirstL@gmail.com&gt;

USAGE:
    training --input &lt;input_path&gt; --output &lt;output_path&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -i, --input &lt;input_path&gt;      
    -o, --output &lt;output_path&gt;    
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-organization--modules"><a class="header" href="#code-organization--modules">Code Organization &amp; Modules</a></h1>
<p>At this point, we're starting to pollute one Rust source file with a few unrelated operations and imports. Rust makes it pretty easy to refactor code into a hierarchy of modules, and sprinkle in encapsulation where appropriate.</p>
<h2 id="whats-a-module"><a class="header" href="#whats-a-module">What's a module?</a></h2>
<p>A module is very similar to a C++ namespace, in that it is a named scope containing declarations of structs, enums, functions, traits, etc.</p>
<p>Let's take a quick look.</p>
<pre><pre class="playground"><code class="language-rust editable">mod say {
    pub fn hello() {
        println!(&quot;I'm a module&quot;);
    }
}

fn main() {
    say::hello();
}
</code></pre></pre>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p>In the simple example above, we also see <code>pub</code> which is a visibility specifier. By default, everything is Rust is visible within the same module, and its descendents. If we want to use a declaration outside of its module, we need to declare it as <code>pub</code>.</p>
<p>Rust also gives you some more tools for fine-grain visibility control:</p>
<ul>
<li><code>pub(super)</code>: visible to containing module</li>
<li><code>pub(crate)</code>: visible to whole containing crate</li>
<li><code>pub(some::path::here)</code>: visible in the specified module namespace</li>
</ul>
<h2 id="ways-to-make-a-module"><a class="header" href="#ways-to-make-a-module">Ways to make a module</a></h2>
<ol>
<li>
<p>The <code>mod {}</code> syntax above</p>
</li>
<li>
<p>As a separate file</p>
</li>
</ol>
<pre><code class="language-ignore">crate
- Cargo.toml
- src
  - lib.rs (or main.rs)
  - mymodule.rs
</code></pre>
<p>In lib.rs (or main.rs):</p>
<pre><code class="language-rust ignore">mod mymodule;
</code></pre>
<p>In mymodule.rs:</p>
<pre><code class="language-rust ignore">pub fn myfunction() {
    ...
}
</code></pre>
<ol start="3">
<li>As a directory (for when your module has modules)</li>
</ol>
<pre><code class="language-ignore">crate
- Cargo.toml
- src
  - lib.rs (or main.rs)
  - bigmodule
    - mod.rs
    - submodule.rs
</code></pre>
<p>In lib.rs (or main.rs):</p>
<pre><code class="language-rust ignore">mod bigmodule;
</code></pre>
<p>In mod.rs:</p>
<pre><code class="language-rust ignore">mod submodule;

fn function_in_bigmodule() {
    ...
}
</code></pre>
<p>In submodule.rs:</p>
<pre><code class="language-rust ignore">fn function_in_submodule() {
    ...
}
</code></pre>
<h2 id="lets-refactor-the-sobel-filter-program"><a class="header" href="#lets-refactor-the-sobel-filter-program">Let's refactor the Sobel filter program</a></h2>
<p>We can refactor the Sobel filter function, convolution function, and kernels into separate modules. This way, the main module is only concerned with user input and calling out to the other modules to execute.</p>
<h2 id="re-exporting"><a class="header" href="#re-exporting">Re-exporting</a></h2>
<p>Rust also includes a mechanism for re-exporting imported modules, functions, structs, etc from within a module. For example, our Sobel filter module could re-export <code>GrayImage</code> since all callers will need to use it.</p>
<pre><code class="language-rust ignore">pub use image::GrayImage;
</code></pre>
<p>You can <code>pub use</code> crates, whole modules, individual functions, or even sets of things (<code>pub use some_crate::{thing1, thing2};</code>).</p>
<h2 id="custom-preludes"><a class="header" href="#custom-preludes">Custom preludes</a></h2>
<p>You probably saw in the previous chapters that to import rayon we used <code>use rayon::prelude::*</code>.</p>
<p>This a common pattern in Rust crates to create an easy way to import a group of functions, traits, etc that are commonly all used together. For example, the standard library also uses this pattern for <code>std::io::prelude::*</code>, which includes most functions, traits, and structs necessary for file I/O.</p>
<p>If we take a look at the <a href="https://docs.rs/rayon/1.1.0/rayon/prelude/index.html">rayon docs</a>, you'll see exactly this pattern.</p>
<p>You create a prelude by creating a module, just like other modules. However, typically prelude modules consist solely of <code>pub use</code> statements.</p>
<pre><code class="language-rust ignore">mod prelude {
    pub use sobel::sobel_filter;
    pub use image::GrayImage;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
